

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>C Interface &mdash; yggdrasil 0.9.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="yggdrasil 0.9.0 documentation" href="../index.html"/>
        <link rel="up" title="Model Interface" href="model_interface.html"/>
        <link rel="next" title="C++ Interface" href="interface_cpp.html"/>
        <link rel="prev" title="Python Interface" href="interface_py.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> yggdrasil
          

          
          </a>

          
            
            
              <div class="version">
                0.9.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../includeme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../formatted_io.html">Formatted I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server_client_io.html">Server/Client I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../server_client_io.html#one-server-two-clients">One Server, Two Clients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../yaml.html">YAML Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../config.html">Configuration Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../c_format_strings.html">C-Style Format Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/examples_toc.html">Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Advanced</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="serialization.html">Serialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="metaschema.html">JSON Metaschema</a></li>
<li class="toctree-l2"><a class="reference internal" href="schema.html">YAML Validation Schema</a></li>
<li class="toctree-l2"><a class="reference internal" href="io_drivers.html">Input/Output Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="model_drivers.html">Model Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="model_drivers.html#model-base-classes">Model Base Classes</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="model_interface.html">Model Interface</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="interface_py.html">Python Interface</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">C Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="interface_cpp.html">C++ Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="interface_m.html">Matlab Interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="code.html">Code</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../development/index.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hackathon2018/index.html">Welcome to the 2018 Crops in Silico Hackathon!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hackathon2019/index.html">Welcome to the 2019 Crops in Silico Hackathon!</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">yggdrasil</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Advanced</a> &raquo;</li>
        
          <li><a href="model_interface.html">Model Interface</a> &raquo;</li>
        
      <li>C Interface</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/advanced/interface_c.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="c-interface">
<h1>C Interface<a class="headerlink" href="#c-interface" title="Permalink to this headline">¶</a></h1>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.yggOutput_t">
<span class="target" id="_ygg_interface_8h_1ab773ec0611a063e87e6cd8159fc88e36"></span><code class="descname">yggOutput_t</code><a class="headerlink" href="#c.yggOutput_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag for checking if YggInterface.h has already been included. </p>
<p>Aliases to preserve names of original structures. </p>
</dd></dl>

<dl class="macro">
<dt id="c.yggInput_t">
<span class="target" id="_ygg_interface_8h_1a06c14c09443eb4175088a4e4a2e1c986"></span><code class="descname">yggInput_t</code><a class="headerlink" href="#c.yggInput_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.ygg_free">
<span class="target" id="_ygg_interface_8h_1ab35f9ca990573a81baeb0dbae4edd8f4"></span><code class="descname">ygg_free</code><a class="headerlink" href="#c.ygg_free" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.yggSend">
<span class="target" id="_ygg_interface_8h_1a5ff7082d1a97c49d32545e4c8c97d1c8"></span><code class="descname">yggSend</code><a class="headerlink" href="#c.yggSend" title="Permalink to this definition">¶</a></dt>
<dd><p>Send arguments as a small formatted message to an output queue. Use the format string to create a message from the input arguments that is then sent to the specified output queue. If the message is larger than YGG_MSG_MAX or cannot be encoded, it will not be sent. </p>
<p>Formatted IO</p>
<p>Output Usage:<ol class="arabic simple">
<li>One-time: Create output channel with format specifier. yggOutput_t output_channel = yggOutputFmt(“out_name”, “a=%d, b=%d”);</li>
<li>Send: ret = yggSend(output_channel, 1, 2);</li>
<li>Free: ygg_free(&amp;output_channel);</li>
</ol>
</p>
<p>Input Usage:<ol class="arabic simple">
<li>One-time: Create output channel with format specifier. yggInput_t input_channel = yggInput(“in_name”, “a=%d, b=%d”);</li>
<li>Prepare: Allocate space for recovered variables. int a, b;</li>
<li>Receive: int ret = yggRecv(input_channel, &amp;a, &amp;b);</li>
</ol>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>int 0 if send succesfull, -1 if send unsuccessful. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">yggQ</span></code>: yggOutput_t structure that queue should be sent to. </li>
<li><code class="docutils literal notranslate"><span class="pre">...</span></code>: arguments to be formatted into a message using sprintf. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.yggRecv">
<span class="target" id="_ygg_interface_8h_1a05cd3bd265a5a40ff231fc565a8ef91a"></span><code class="descname">yggRecv</code><a class="headerlink" href="#c.yggRecv" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign arguments by receiving and parsing a message from an input queue. Receive a message smaller than YGG_MSG_MAX bytes from an input queue and parse it using the associated format string. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>int -1 if message could not be received or could not be parsed. Length of the received message if message was received and parsed. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">yggQ</span></code>: yggOutput_t structure that message should be sent to. </li>
<li><code class="docutils literal notranslate"><span class="pre">...</span></code>: arguments that should be assigned by parsing the received message using sscanf. As these are being assigned, they should be pointers to memory that has already been allocated. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.yggRecvRealloc">
<span class="target" id="_ygg_interface_8h_1a1b9b4af013b9fe98df891c30e97a5ca2"></span><code class="descname">yggRecvRealloc</code><a class="headerlink" href="#c.yggRecvRealloc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.vyggSend">
<span class="target" id="_ygg_interface_8h_1ad98250140649c48b4f1574f958e73ed3"></span><code class="descname">vyggSend</code><a class="headerlink" href="#c.vyggSend" title="Permalink to this definition">¶</a></dt>
<dd><p>Definitions for symmetry, but there is no difference. </p>
</dd></dl>

<dl class="macro">
<dt id="c.vyggRecv">
<span class="target" id="_ygg_interface_8h_1a49bfdad21c411fdd610b79d03b237521"></span><code class="descname">vyggRecv</code><a class="headerlink" href="#c.vyggRecv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.vyggSend_nolimit">
<span class="target" id="_ygg_interface_8h_1a91afa729c22c20e1abf18fccc4b440f4"></span><code class="descname">vyggSend_nolimit</code><a class="headerlink" href="#c.vyggSend_nolimit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.vyggRecv_nolimit">
<span class="target" id="_ygg_interface_8h_1a9912b11112c52fb57bac405bf8ecf5fd"></span><code class="descname">vyggRecv_nolimit</code><a class="headerlink" href="#c.vyggRecv_nolimit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.yggSend_nolimit">
<span class="target" id="_ygg_interface_8h_1aec6276eca942a416ad39d2529f4f24dc"></span><code class="descname">yggSend_nolimit</code><a class="headerlink" href="#c.yggSend_nolimit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.yggRecv_nolimit">
<span class="target" id="_ygg_interface_8h_1aef5b1f679ee45a7fb86dfa64ab4d7ba4"></span><code class="descname">yggRecv_nolimit</code><a class="headerlink" href="#c.yggRecv_nolimit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.yggRpc_t">
<span class="target" id="_ygg_interface_8h_1ab0b3337d54a2c580a80ba374c29590cf"></span><code class="descname">yggRpc_t</code><a class="headerlink" href="#c.yggRpc_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Remote Procedure Call (RPC) structure. Contains information required to coordinate sending/receiving response/requests from/to an RPC server/client. </p>
<p>Remote Procedure Call (RPC) IO</p>
<p>Handle IO case of a server receiving input from clients, performing some calculation, and then sending a response back to the client.</p>
<p>Server Usage:<ol class="arabic simple">
<li>One-time: Create server channels with format specifiers for input and output. yggRpc_t srv = yggRpcServer(“srv_name”, “%d”, “%d %d”);</li>
<li>Prepare: Allocate space for recovered variables from request. int a;</li>
<li>Receive request: int ret = rpcRecv(srv, &amp;a);</li>
<li>Process: Do tasks the server should do with input to produce output. int b = 2*a; int c = 3*a;</li>
<li>Send response: ret = rpcSend(srv, b, c);</li>
</ol>
</p>
<p>Client Usage:<ol class="arabic simple">
<li>One-time: Create client channels to desired server with format specifiers for output and input (should be the same arguments as for the server except for name). yggRpc_t cli = yggRpcClient(“cli_name”, “%d”, “%d %d”);</li>
<li>Prepare: Allocate space for recovered variables from response. int b, c;</li>
<li>Call server: int ret = rpcCall(cli, 1, &amp;b, &amp;c);</li>
</ol>
</p>
<p>Clients can also send several requests at once before receiving any responses. This allows the server to be processing the next requests while the client handles the previous response, thereby increasing efficiency. The responses are assumed to be in the same order as the generating requests (i.e. first come, first served). </p>
</dd></dl>

<dl class="macro">
<dt id="c.vrpcSend">
<span class="target" id="_ygg_interface_8h_1a0b20b07df7ba63e6b950f9b11c7c8ee5"></span><code class="descname">vrpcSend</code><a class="headerlink" href="#c.vrpcSend" title="Permalink to this definition">¶</a></dt>
<dd><p>Format and send a message to an RPC output queue. Format provided arguments list using the output queue format string and then sends it to the output queue under the assumption that it is larger than the maximum message size. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>integer specifying if the send was succesful. Values &gt;= 0 indicate success. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">rpc</span></code>: yggRpc_t structure with RPC information. </li>
<li><code class="docutils literal notranslate"><span class="pre">ap</span></code>: va_list variable list of arguments for formatting. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.vrpcRecv">
<span class="target" id="_ygg_interface_8h_1afeac902932aa1cfa08d07504d93247f0"></span><code class="descname">vrpcRecv</code><span class="sig-paren">(</span>rpc, nargs, ap<span class="sig-paren">)</span><a class="headerlink" href="#c.vrpcRecv" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive and parse a message from an RPC input queue. Receive a message from the input queue under the assumption that it is larger than the maximum message size. Then parse the message using the input queue format string to extract parameters and assign them to the arguments. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>integer specifying if the receive was succesful. Values &gt;= 0 indicate success. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">rpc</span></code>: yggRpc_t structure with RPC information. </li>
<li><code class="docutils literal notranslate"><span class="pre">nargs</span></code>: int Number of arguments contained in ap. </li>
<li><code class="docutils literal notranslate"><span class="pre">ap</span></code>: va_list variable list of arguments that should be assigned parameters extracted using the format string. Since these will be assigned, they should be pointers to memory that has already been allocated. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.vrpcRecvRealloc">
<span class="target" id="_ygg_interface_8h_1a80b8fe73f32501f9995c66f2305485fa"></span><code class="descname">vrpcRecvRealloc</code><span class="sig-paren">(</span>rpc, nargs, ap<span class="sig-paren">)</span><a class="headerlink" href="#c.vrpcRecvRealloc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.rpcSend">
<span class="target" id="_ygg_interface_8h_1a36934867230c32242f9a254154f86d61"></span><code class="descname">rpcSend</code><a class="headerlink" href="#c.rpcSend" title="Permalink to this definition">¶</a></dt>
<dd><p>Format and send a message to an RPC output queue. Format provided arguments using the output queue format string and then sends it to the output queue under the assumption that it is larger than the maximum message size. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>integer specifying if the send was succesful. Values &gt;= 0 indicate success. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">rpc</span></code>: yggRpc_t structure with RPC information. </li>
<li><code class="docutils literal notranslate"><span class="pre">...</span></code>: arguments for formatting. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.rpcRecv">
<span class="target" id="_ygg_interface_8h_1a125a00cdd013863abed6dd0a4717b90c"></span><code class="descname">rpcRecv</code><a class="headerlink" href="#c.rpcRecv" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive and parse a message from an RPC input queue. Receive a message from the input queue under the assumption that it is larger than the maximum message size. Then parse the message using the input queue format string to extract parameters and assign them to the arguments. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>integer specifying if the receive was succesful. Values &gt;= 0 indicate success. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">rpc</span></code>: yggRpc_t structure with RPC information. </li>
<li><code class="docutils literal notranslate"><span class="pre">...</span></code>: mixed arguments that should be assigned parameters extracted using the format string. Since these will be assigned, they should be pointers to memory that has already been allocated. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.rpcRecvRealloc">
<span class="target" id="_ygg_interface_8h_1aaed1b3d36767ebba8623f1eba67948c0"></span><code class="descname">rpcRecvRealloc</code><a class="headerlink" href="#c.rpcRecvRealloc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.vrpcCall">
<span class="target" id="_ygg_interface_8h_1aec917202f485fbe570338df7a51e85a1"></span><code class="descname">vrpcCall</code><span class="sig-paren">(</span>rpc, nargs, ap<span class="sig-paren">)</span><a class="headerlink" href="#c.vrpcCall" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.vrpcCallRealloc">
<span class="target" id="_ygg_interface_8h_1ad7ff6c764c98d7b6cf7e91462ecd13e2"></span><code class="descname">vrpcCallRealloc</code><span class="sig-paren">(</span>rpc, nargs, ap<span class="sig-paren">)</span><a class="headerlink" href="#c.vrpcCallRealloc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.rpcCall">
<span class="target" id="_ygg_interface_8h_1aeb0908a4a0988f574bacec28c7c9b171"></span><code class="descname">rpcCall</code><span class="sig-paren">(</span>rpc, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.rpcCall" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.rpcCallRealloc">
<span class="target" id="_ygg_interface_8h_1a1c07d8a58f5c9896bea745ec6e8df613"></span><code class="descname">rpcCallRealloc</code><span class="sig-paren">(</span>rpc, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.rpcCallRealloc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.yggAsciiFileInput_t">
<span class="target" id="_ygg_interface_8h_1aa5e0636b4895d53315e4fe064959c778"></span><code class="descname">yggAsciiFileInput_t</code><a class="headerlink" href="#c.yggAsciiFileInput_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Definitions for file sturctures. </p>
<p>File IO</p>
<p>Handle I/O from/to a file line by line.</p>
<p>Input Usage:<ol class="arabic simple">
<li>One-time: Create file interface by providing a channel name. comm_t fin = yggAsciiFileInput(“file_channel”);</li>
<li>Prepare: Get pointer for line. char *line;</li>
<li>Receive each line, terminating when receive returns -1 (EOF or channel closed). int ret = 1; while (ret &gt; 0) { ret = yggRecv(fin, &amp;line); // line will be realloced to fit message Do something with the line }</li>
<li>Cleanup. Call functions to deallocate structures. free(line);</li>
</ol>
</p>
<p>Output Usage:<ol class="arabic simple">
<li>One-time: Create file interface by providing a channel name. comm_t fout = yggAsciiFileOutput(“file_channel”);</li>
<li>Send lines to the file. If return value is not 0, the send was not succesfull. int ret; ret = yggSend(fin, “Line 1\n”); ret = yggSend(fout, “Line 1\n”); ret = yggSend(fout, “Line 2\n”); </li>
</ol>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.yggAsciiFileOutput_t">
<span class="target" id="_ygg_interface_8h_1a4ed51dda758e9e2d7650d97f52b9e31a"></span><code class="descname">yggAsciiFileOutput_t</code><a class="headerlink" href="#c.yggAsciiFileOutput_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.yggAsciiTableInput_t">
<span class="target" id="_ygg_interface_8h_1aebb3ede6c4eab9bc8657b9126f691417"></span><code class="descname">yggAsciiTableInput_t</code><a class="headerlink" href="#c.yggAsciiTableInput_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Definitions for table sturctures. </p>
<p>Table IO</p>
<p>Handle I/O from/to an ASCII table either line-by-line or as an array.</p>
<p><em>Row-by-Row </em></p>
<p>Input by Row Usage:<ol class="arabic simple">
<li>One-time: Create file interface by providing a channel name. comm_t fin = yggAsciiTableInput(“file_channel”);</li>
<li>Prepare: Allocate space for variables in row (the format in this example is “%5s %d %f\n” like the output example below). char a[5]; int b; double c;</li>
<li>Receive each row, terminating when receive returns -1 (EOF or channel closed). int ret = 1; while (ret &gt; 0) { ret = yggRecv(fin, &amp;a, &amp;b, &amp;c); Do something with the row }</li>
</ol>
</p>
<p>Output by Row Usage:<ol class="arabic simple">
<li>One-time: Create file interface by providing a channel name and a format string for rows. comm_t fout = yggAsciiTableOutput(“file_channel”, “%5s %d %f\n”);</li>
<li>Send rows to the file by providing entries. Formatting is handled by the interface. If return value is not 0, the send was not succesful. int ret; ret = yggSend(fout, “one”, 1, 1.0); ret = yggSend(fout, “two”, 2, 2.0);</li>
</ol>
</p>
<p><em>Array </em></p>
<p>Input by Array Usage:<ol class="arabic simple">
<li>One-time: Create file interface by providing a channel name. comm_t fin = yggAsciiArrayInput(“file_channel”);</li>
<li>Prepare: Declare pointers for table columns (they will be allocated by the interface once the number of rows is known). char *aCol; int *bCol; double *cCol;</li>
<li>Receive entire table as columns. Return value will be the number of elements in each column (the number of table rows). Negative values indicate errors. int ret = yggRecv(fin, &amp;a, &amp;b, &amp;c);</li>
<li>Cleanup. Call functions to deallocate structures. free(a); free(b); free(c);</li>
</ol>
</p>
<p>Output by Array Usage:<ol class="arabic simple">
<li>One-time: Create file interface by providing a channel name and a format string for rows. comm_t fout = yggAsciiArrayOutput(“file_channel”, “%5s %d %f\n”);</li>
<li>Send columns to the file by providing pointers (or arrays). Formatting is handled by the interface. If return value is not 0, the send was not succesful. char aCol[] = {“one  “, “two  “, “three”}; \ Each str is of len 5 int bCol[3] = {1, 2, 3}; float cCol[3] = {1.0, 2.0, 3.0}; int ret = yggSend(fout, a, b, c); </li>
</ol>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.yggAsciiTableOutput_t">
<span class="target" id="_ygg_interface_8h_1a349953af8d7e67d33e58e4688af2cd50"></span><code class="descname">yggAsciiTableOutput_t</code><a class="headerlink" href="#c.yggAsciiTableOutput_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.yggAsciiArrayInput_t">
<span class="target" id="_ygg_interface_8h_1ac4403c44853004d0d54edd6d2ac5beae"></span><code class="descname">yggAsciiArrayInput_t</code><a class="headerlink" href="#c.yggAsciiArrayInput_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.yggAsciiArrayOutput_t">
<span class="target" id="_ygg_interface_8h_1ac7b4f75530d9481e38cf95ae14462cdb"></span><code class="descname">yggAsciiArrayOutput_t</code><a class="headerlink" href="#c.yggAsciiArrayOutput_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.yggPlyInput_t">
<span class="target" id="_ygg_interface_8h_1ab02f4ec2d29e21c952b69ab105183d8e"></span><code class="descname">yggPlyInput_t</code><a class="headerlink" href="#c.yggPlyInput_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Definitions for ply structures. </p>
<p>Ply IO</p>
<p>Handle I/O from/to a Ply file.</p>
<p>Input Usage:<ol class="arabic simple">
<li>One-time: Create file interface by providing a channel name. comm_t fin = yggPlyInput(“file_channel”); // channel</li>
<li>Prepare: Allocate ply structure. ply_t p;</li>
<li>Receive each structure, terminating when receive returns -1 (EOF or channel closed). int ret = 1; while (ret &gt; 0) { ret = yggRecv(fin, &amp;p); Do something with the ply structure }</li>
</ol>
</p>
<p>Output by Usage:<ol class="arabic simple">
<li>One-time: Create file interface by providing a channel name. comm_t fout = yggPlyOutput(“file_channel”); // channel</li>
<li>Send structure to the file by providing entries. Formatting is handled by the interface. If return value is not 0, the send was not succesful. int ret; ply_t p; Populate the structure ret = yggSend(fout, p); ret = yggSend(fout, p); </li>
</ol>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.yggPlyOutput_t">
<span class="target" id="_ygg_interface_8h_1acf9ee3034e698672b2d161df32b7f55c"></span><code class="descname">yggPlyOutput_t</code><a class="headerlink" href="#c.yggPlyOutput_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="macro">
<dt id="c.yggObjInput_t">
<span class="target" id="_ygg_interface_8h_1ae6261feebfad23850846b8bb000a82df"></span><code class="descname">yggObjInput_t</code><a class="headerlink" href="#c.yggObjInput_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Definitions for obj structures. </p>
<p>Obj IO</p>
<p>Handle I/O from/to a Obj file.</p>
<p>Input Usage:<ol class="arabic simple">
<li>One-time: Create file interface by providing a channel name. comm_t fin = yggObjInput(“file_channel”); // channel</li>
<li>Prepare: Allocate obj structure. obj_t p;</li>
<li>Receive each structure, terminating when receive returns -1 (EOF or channel closed). int ret = 1; while (ret &gt; 0) { ret = yggRecv(fin, &amp;p); Do something with the obj structure }</li>
</ol>
</p>
<p>Output by Usage:<ol class="arabic simple">
<li>One-time: Create file interface by providing a channel name. comm_t fout = yggObjOutput(“file_channel”); // channel</li>
<li>Send structure to the file by providing entries. Formatting is handled by the interface. If return value is not 0, the send was not succesful. int ret; obj_t p; Populate the structure ret = yggSend(fout, p); ret = yggSend(fout, p); </li>
</ol>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.yggObjOutput_t">
<span class="target" id="_ygg_interface_8h_1ad5cf4cfadcc85a3933cf43b47ce94630"></span><code class="descname">yggObjOutput_t</code><a class="headerlink" href="#c.yggObjOutput_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv412yggOutputFmtPKcPKc">
<span id="_CPPv312yggOutputFmtPKcPKc"></span><span id="_CPPv212yggOutputFmtPKcPKc"></span><span id="yggOutputFmt__cCP.cCP"></span><span class="target" id="_ygg_interface_8h_1a96c28a745d83625613d98d055966f9f0"></span><em class="property">static</em> yggOutput_t <code class="descname">yggOutputFmt</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em>, <em class="property">const</em> char *<em>fmtString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412yggOutputFmtPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for yggOutput_t structure with format. Create a yggOutput_t structure based on a provided name that is used to locate a particular comm address stored in the environment variable name and a format string that can be used to format arguments into outgoing messages for the queue. </p>
<p>Basic IO</p>
<p>Output Usage:<ol class="arabic simple">
<li>One-time: Create output channel (store in named variables) yggOutput_t output_channel = yggOutput(“out_name”);</li>
<li>Prepare: Format data to a character array buffer. char buffer[YGG_MSG_BUF]; sprintf(buffer, “a=%d, b=%d”, 1, 2);</li>
<li>Send: ret = ygg_send(output_channel, buffer, strlen(buffer));</li>
</ol>
</p>
<p>Input Usage:<ol class="arabic simple">
<li>One-time: Create output channel (store in named variables) yggInput_t input_channel = yggInput(“in_name”);</li>
<li>Prepare: Allocate a character array buffer. char buffer[YGG_MSG_BUF];</li>
<li>Receive: int ret = ygg_recv(input_channel, buffer, YGG_MSG_BUF);</li>
</ol>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>yggOutput_t output queue structure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to name of queue. </li>
<li><code class="docutils literal notranslate"><span class="pre">fmtString</span></code>: character pointer to format string. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411yggInputFmtPKcPKc">
<span id="_CPPv311yggInputFmtPKcPKc"></span><span id="_CPPv211yggInputFmtPKcPKc"></span><span id="yggInputFmt__cCP.cCP"></span><span class="target" id="_ygg_interface_8h_1a82929b85080665bd452665bcd56bd27f"></span><em class="property">static</em> yggInput_t <code class="descname">yggInputFmt</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em>, <em class="property">const</em> char *<em>fmtString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411yggInputFmtPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for yggInput_t structure with format. Create a yggInput_t structure based on a provided name that is used to locate a particular comm address stored in the environment variable name and a format stirng that can be used to extract arguments from received messages. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>yggInput_t input queue structure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to name of queue. </li>
<li><code class="docutils literal notranslate"><span class="pre">fmtString</span></code>: character pointer to format string. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv49yggOutputPKc">
<span id="_CPPv39yggOutputPKc"></span><span id="_CPPv29yggOutputPKc"></span><span id="yggOutput__cCP"></span><span class="target" id="_ygg_interface_8h_1afaa901b91a8353fcd4a34eca1f6ee7cd"></span><em class="property">static</em> yggOutput_t <code class="descname">yggOutput</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv49yggOutputPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for yggOutput_t output structure. Create a yggOutput_t structure based on a provided name that is used to locate a particular comm address stored in the environment variable name. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>yggOutput_t output queue structure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to name of queue. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48yggInputPKc">
<span id="_CPPv38yggInputPKc"></span><span id="_CPPv28yggInputPKc"></span><span id="yggInput__cCP"></span><span class="target" id="_ygg_interface_8h_1a0ade4dc07ba579bb7a5f766c97fc09fe"></span><em class="property">static</em> yggInput_t <code class="descname">yggInput</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48yggInputPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for yggInput_t structure. Create a yggInput_t structure based on a provided name that is used to locate a particular comm address stored in the environment variable name. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>yggInput_t input queue structure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to name of queue. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48ygg_sendK11yggOutput_tPKcK6size_t">
<span id="_CPPv38ygg_sendK11yggOutput_tPKcK6size_t"></span><span id="_CPPv28ygg_sendK11yggOutput_tPKcK6size_t"></span><span id="ygg_send__yggOutput_tC.cCP.sC"></span><span class="target" id="_ygg_interface_8h_1a98da80acacba97584045dd92d47944f1"></span><em class="property">static</em> int <code class="descname">ygg_send</code><span class="sig-paren">(</span><em class="property">const</em> yggOutput_t <em>yggQ</em>, <em class="property">const</em> char *<em>data</em>, <em class="property">const</em> size_t <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48ygg_sendK11yggOutput_tPKcK6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send a message to an output queue. Send a message smaller than YGG_MSG_MAX bytes to an output queue. If the message is larger, it will not be sent. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>int 0 if send succesfull, -1 if send unsuccessful. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">yggQ</span></code>: yggOutput_t structure that queue should be sent to. </li>
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: character pointer to message that should be sent. </li>
<li><code class="docutils literal notranslate"><span class="pre">len</span></code>: size_t length of message to be sent. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412ygg_send_eofK11yggOutput_t">
<span id="_CPPv312ygg_send_eofK11yggOutput_t"></span><span id="_CPPv212ygg_send_eofK11yggOutput_t"></span><span id="ygg_send_eof__yggOutput_tC"></span><span class="target" id="_ygg_interface_8h_1a05945a6d511e6551a52488659fbcbd13"></span><em class="property">static</em> int <code class="descname">ygg_send_eof</code><span class="sig-paren">(</span><em class="property">const</em> yggOutput_t <em>yggQ</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412ygg_send_eofK11yggOutput_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send EOF message to the output queue. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>int 0 if send successfull, -1 if unsuccessful. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">yggQ</span></code>: yggOutput_t structure that message should be sent to. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv48ygg_recvK10yggInput_tPcK6size_t">
<span id="_CPPv38ygg_recvK10yggInput_tPcK6size_t"></span><span id="_CPPv28ygg_recvK10yggInput_tPcK6size_t"></span><span id="ygg_recv__yggInput_tC.cP.sC"></span><span class="target" id="_ygg_interface_8h_1a1a215fb2d8289e219e62ed654816b1e7"></span><em class="property">static</em> int <code class="descname">ygg_recv</code><span class="sig-paren">(</span><em class="property">const</em> yggInput_t <em>yggQ</em>, char *<em>data</em>, <em class="property">const</em> size_t <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv48ygg_recvK10yggInput_tPcK6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Receive a message from an input queue. Receive a message smaller than YGG_MSG_MAX bytes from an input queue. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>int -1 if message could not be received. Length of the received message if message was received. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">yggQ</span></code>: yggOutput_t structure that message should be sent to. </li>
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: character pointer to allocated buffer where the message should be saved. </li>
<li><code class="docutils literal notranslate"><span class="pre">len</span></code>: const size_t length of the allocated message buffer in bytes. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416ygg_send_nolimitK11yggOutput_tPKcK6size_t">
<span id="_CPPv316ygg_send_nolimitK11yggOutput_tPKcK6size_t"></span><span id="_CPPv216ygg_send_nolimitK11yggOutput_tPKcK6size_t"></span><span id="ygg_send_nolimit__yggOutput_tC.cCP.sC"></span><span class="target" id="_ygg_interface_8h_1a9e52c095b08ed33fb7251e5d199d07c9"></span><em class="property">static</em> int <code class="descname">ygg_send_nolimit</code><span class="sig-paren">(</span><em class="property">const</em> yggOutput_t <em>yggQ</em>, <em class="property">const</em> char *<em>data</em>, <em class="property">const</em> size_t <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416ygg_send_nolimitK11yggOutput_tPKcK6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send a large message to an output queue. Send a message larger than YGG_MSG_MAX bytes to an output queue by breaking it up between several smaller messages and sending initial message with the size of the message that should be expected. Must be partnered with ygg_recv_nolimit for communication to make sense. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>int 0 if send succesfull, -1 if send unsuccessful. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">yggQ</span></code>: yggOutput_t structure that message should be sent to. </li>
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: character pointer to message that should be sent. </li>
<li><code class="docutils literal notranslate"><span class="pre">len</span></code>: size_t length of message to be sent. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv420ygg_send_nolimit_eofK11yggOutput_t">
<span id="_CPPv320ygg_send_nolimit_eofK11yggOutput_t"></span><span id="_CPPv220ygg_send_nolimit_eofK11yggOutput_t"></span><span id="ygg_send_nolimit_eof__yggOutput_tC"></span><span class="target" id="_ygg_interface_8h_1ae369bebe2617cb0d997c7ac7e35e7236"></span><em class="property">static</em> int <code class="descname">ygg_send_nolimit_eof</code><span class="sig-paren">(</span><em class="property">const</em> yggOutput_t <em>yggQ</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420ygg_send_nolimit_eofK11yggOutput_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send EOF message to the output queue. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>int 0 if send successfull, -1 if unsuccessful. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">yggQ</span></code>: yggOutput_t structure that message should be sent to. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv416ygg_recv_nolimitK10yggInput_tPPcK6size_t">
<span id="_CPPv316ygg_recv_nolimitK10yggInput_tPPcK6size_t"></span><span id="_CPPv216ygg_recv_nolimitK10yggInput_tPPcK6size_t"></span><span id="ygg_recv_nolimit__yggInput_tC.cPP.sC"></span><span class="target" id="_ygg_interface_8h_1a637b65efd6e05c2aa6e15dc6abf8d1b1"></span><em class="property">static</em> int <code class="descname">ygg_recv_nolimit</code><span class="sig-paren">(</span><em class="property">const</em> yggInput_t <em>yggQ</em>, char **<em>data</em>, <em class="property">const</em> size_t <em>len</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416ygg_recv_nolimitK10yggInput_tPPcK6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Receive a large message from an input queue. Receive a message larger than YGG_MSG_MAX bytes from an input queue by receiving it in parts. This expects the first message to be the size of the total message. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>int -1 if message could not be received. Length of the received message if message was received. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">yggQ</span></code>: yggOutput_t structure that message should be sent to. </li>
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: character pointer to pointer for allocated buffer where the message should be stored. A pointer to a pointer is used so that the buffer may be reallocated as necessary for the incoming message. </li>
<li><code class="docutils literal notranslate"><span class="pre">len</span></code>: size_t length of the initial allocated message buffer in bytes. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412yggRpcClientPKcPKcPKc">
<span id="_CPPv312yggRpcClientPKcPKcPKc"></span><span id="_CPPv212yggRpcClientPKcPKcPKc"></span><span id="yggRpcClient__cCP.cCP.cCP"></span><span class="target" id="_ygg_interface_8h_1a9a8a15fd46d28a7abb7f23c9a2bf695a"></span><em class="property">static</em> comm_t <code class="descname">yggRpcClient</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em>, <em class="property">const</em> char *<em>outFormat</em>, <em class="property">const</em> char *<em>inFormat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412yggRpcClientPKcPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for client side RPC structure. Creates an instance of yggRpc_t with provided information. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>yggRpc_t structure with provided info. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to name for queues. </li>
<li><code class="docutils literal notranslate"><span class="pre">outFormat</span></code>: character pointer to format that should be used for formatting output. </li>
<li><code class="docutils literal notranslate"><span class="pre">inFormat</span></code>: character pointer to format that should be used for parsing input. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412yggRpcServerPKcPKcPKc">
<span id="_CPPv312yggRpcServerPKcPKcPKc"></span><span id="_CPPv212yggRpcServerPKcPKcPKc"></span><span id="yggRpcServer__cCP.cCP.cCP"></span><span class="target" id="_ygg_interface_8h_1ad2b4bbdfe1701ea0675a070713099bae"></span><em class="property">static</em> comm_t <code class="descname">yggRpcServer</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em>, <em class="property">const</em> char *<em>inFormat</em>, <em class="property">const</em> char *<em>outFormat</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412yggRpcServerPKcPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for server side RPC structure. Creates an instance of yggRpc_t with provided information. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>yggRpc_t structure with provided info. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to name for queues. </li>
<li><code class="docutils literal notranslate"><span class="pre">inFormat</span></code>: character pointer to format that should be used for parsing input. </li>
<li><code class="docutils literal notranslate"><span class="pre">outFormat</span></code>: character pointer to format that should be used for formatting output. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412vrpcCallBaseK8yggRpc_tKi6size_t9va_list_t">
<span id="_CPPv312vrpcCallBaseK8yggRpc_tKi6size_t9va_list_t"></span><span id="_CPPv212vrpcCallBaseK8yggRpc_tKi6size_t9va_list_t"></span><span id="vrpcCallBase__yggRpc_tC.iC.s.va_list_t"></span><span class="target" id="_ygg_interface_8h_1ab4686596bbafd53898c27c603b542626"></span><em class="property">static</em> int <code class="descname">vrpcCallBase</code><span class="sig-paren">(</span><em class="property">const</em> yggRpc_t <em>rpc</em>, <em class="property">const</em> int <em>allow_realloc</em>, size_t <em>nargs</em>, va_list_t <em>ap</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412vrpcCallBaseK8yggRpc_tKi6size_t9va_list_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send request to an RPC server from the client and wait for a response. Format arguments using the output queue format string, send the message to the output queue, receive a response from the input queue, and assign arguments from the message using the input queue format string to parse it. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>integer specifying if the receive was succesful. Values &gt;= 0 indicate success. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">rpc</span></code>: yggRpc_t structure with RPC information. </li>
<li><code class="docutils literal notranslate"><span class="pre">allow_realloc</span></code>: int If 1, output arguments are assumed to be pointers to pointers such that they can be reallocated as necessary to receive incoming data. If 0, output arguments are assumed to be preallocated. </li>
<li><code class="docutils literal notranslate"><span class="pre">nargs</span></code>: size_t Number of arguments contained in ap including both input and output arguments. </li>
<li><code class="docutils literal notranslate"><span class="pre">ap</span></code>: va_list mixed arguments that include those that should be formatted using the output format string, followed by those that should be assigned parameters extracted using the input format string. These that will be assigned should be pointers to memory that has already been allocated. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412nrpcCallBaseK8yggRpc_tKi6size_tz">
<span id="_CPPv312nrpcCallBaseK8yggRpc_tKi6size_tz"></span><span id="_CPPv212nrpcCallBaseK8yggRpc_tKi6size_tz"></span><span id="nrpcCallBase__yggRpc_tC.iC.s.z"></span><span class="target" id="_ygg_interface_8h_1acedf6b6f31421ffde78f94d0a5ea8c76"></span><em class="property">static</em> int <code class="descname">nrpcCallBase</code><span class="sig-paren">(</span><em class="property">const</em> yggRpc_t <em>rpc</em>, <em class="property">const</em> int <em>allow_realloc</em>, size_t <em>nargs</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412nrpcCallBaseK8yggRpc_tKi6size_tz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send request to an RPC server from the client and wait for a response. Format arguments using the output queue format string, send the message to the output queue, receive a response from the input queue, and assign arguments from the message using the input queue format string to parse it. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>integer specifying if the receive was succesful. Values &gt;= 0 indicate success. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">rpc</span></code>: yggRpc_t structure with RPC information. </li>
<li><code class="docutils literal notranslate"><span class="pre">allow_realloc</span></code>: int If 1, output arguments are assumed to be pointers to pointers such that they can be reallocated as necessary to receive incoming data. If 0, output arguments are assumed to be preallocated. </li>
<li><code class="docutils literal notranslate"><span class="pre">nargs</span></code>: size_t Number of arguments contained in ap including both input and output arguments. </li>
<li><code class="docutils literal notranslate"><span class="pre">...</span></code>: mixed arguments that include those that should be formatted using the output format string, followed by those that should be assigned parameters extracted using the input format string. These that will be assigned should be pointers to memory that has already been allocated. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418yggAsciiFileOutputPKc">
<span id="_CPPv318yggAsciiFileOutputPKc"></span><span id="_CPPv218yggAsciiFileOutputPKc"></span><span id="yggAsciiFileOutput__cCP"></span><span class="target" id="_ygg_interface_8h_1a019ef23fdc43204bed37e5f959ca5b59"></span><em class="property">static</em> comm_t <code class="descname">yggAsciiFileOutput</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418yggAsciiFileOutputPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for AsciiFile output comm to channel. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>comm_t for line-by-line output to a file or channel. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to name of an output channel. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv417yggAsciiFileInputPKc">
<span id="_CPPv317yggAsciiFileInputPKc"></span><span id="_CPPv217yggAsciiFileInputPKc"></span><span id="yggAsciiFileInput__cCP"></span><span class="target" id="_ygg_interface_8h_1a6240c40b983fb8f00fef8e2dca72713b"></span><em class="property">static</em> comm_t <code class="descname">yggAsciiFileInput</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417yggAsciiFileInputPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for AsciiFile input comm from channel. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>comm_t for line-by-line input from a file or channel. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to name of an input channel. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419yggAsciiTableOutputPKcPKc">
<span id="_CPPv319yggAsciiTableOutputPKcPKc"></span><span id="_CPPv219yggAsciiTableOutputPKcPKc"></span><span id="yggAsciiTableOutput__cCP.cCP"></span><span class="target" id="_ygg_interface_8h_1a935030615117f90f3e4abb7651a3b23d"></span><em class="property">static</em> comm_t <code class="descname">yggAsciiTableOutput</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em>, <em class="property">const</em> char *<em>format_str</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419yggAsciiTableOutputPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for table output comm to an output channel. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>comm_t output structure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to output channel name. </li>
<li><code class="docutils literal notranslate"><span class="pre">format_str</span></code>: character pointer to format string that should be used to format rows into table lines. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418yggAsciiTableInputPKc">
<span id="_CPPv318yggAsciiTableInputPKc"></span><span id="_CPPv218yggAsciiTableInputPKc"></span><span id="yggAsciiTableInput__cCP"></span><span class="target" id="_ygg_interface_8h_1a89df62121cd78ce0a84559b8b9edfe7e"></span><em class="property">static</em> comm_t <code class="descname">yggAsciiTableInput</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418yggAsciiTableInputPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for AsciiTable input comm from an input channel. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>comm_t input structure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to input channel name. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv419yggAsciiArrayOutputPKcPKc">
<span id="_CPPv319yggAsciiArrayOutputPKcPKc"></span><span id="_CPPv219yggAsciiArrayOutputPKcPKc"></span><span id="yggAsciiArrayOutput__cCP.cCP"></span><span class="target" id="_ygg_interface_8h_1a5c653ef9eaa35c9920a9d26f42e63cb5"></span><em class="property">static</em> comm_t <code class="descname">yggAsciiArrayOutput</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em>, <em class="property">const</em> char *<em>format_str</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv419yggAsciiArrayOutputPKcPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for table output comm with array output. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>comm_t output structure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to an output channel name. </li>
<li><code class="docutils literal notranslate"><span class="pre">format_str</span></code>: character pointer to format string that should be used to format rows into table lines. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv418yggAsciiArrayInputPKc">
<span id="_CPPv318yggAsciiArrayInputPKc"></span><span id="_CPPv218yggAsciiArrayInputPKc"></span><span id="yggAsciiArrayInput__cCP"></span><span class="target" id="_ygg_interface_8h_1acb64a59268001896dfbcba1efd929437"></span><em class="property">static</em> comm_t <code class="descname">yggAsciiArrayInput</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv418yggAsciiArrayInputPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for AsciiTable input comm with array input. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>comm_t input structure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to an input channel name. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412yggPlyOutputPKc">
<span id="_CPPv312yggPlyOutputPKc"></span><span id="_CPPv212yggPlyOutputPKc"></span><span id="yggPlyOutput__cCP"></span><span class="target" id="_ygg_interface_8h_1a03f4a6654ab0fdd063d4883def0471f0"></span><em class="property">static</em> comm_t <code class="descname">yggPlyOutput</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412yggPlyOutputPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for ply output comm to an output channel. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>comm_t output structure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to output channel name. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411yggPlyInputPKc">
<span id="_CPPv311yggPlyInputPKc"></span><span id="_CPPv211yggPlyInputPKc"></span><span id="yggPlyInput__cCP"></span><span class="target" id="_ygg_interface_8h_1a03bf2d5b82e20a2294637f9be67decae"></span><em class="property">static</em> comm_t <code class="descname">yggPlyInput</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411yggPlyInputPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for ply input comm from an input channel. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>comm_t input structure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to input channel name. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv412yggObjOutputPKc">
<span id="_CPPv312yggObjOutputPKc"></span><span id="_CPPv212yggObjOutputPKc"></span><span id="yggObjOutput__cCP"></span><span class="target" id="_ygg_interface_8h_1afd8b4331638ce903973e0558537181e2"></span><em class="property">static</em> comm_t <code class="descname">yggObjOutput</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv412yggObjOutputPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for obj output comm to an output channel. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>comm_t output structure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to output channel name. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv411yggObjInputPKc">
<span id="_CPPv311yggObjInputPKc"></span><span id="_CPPv211yggObjInputPKc"></span><span id="yggObjInput__cCP"></span><span class="target" id="_ygg_interface_8h_1a75528f26156a1cbc6297fcbb0890cb1d"></span><em class="property">static</em> comm_t <code class="descname">yggObjInput</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv411yggObjInputPKc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor for obj input comm from an input channel. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>comm_t input structure. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: constant character pointer to input channel name. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="interface_cpp.html" class="btn btn-neutral float-right" title="C++ Interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="interface_py.html" class="btn btn-neutral" title="Python Interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Meagan Lang, David Raila.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.9.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>