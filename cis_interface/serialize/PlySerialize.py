import getpass
import copy
import numpy as np
import matplotlib as mpl
import matplotlib.cm as cm
from cis_interface import backwards
from cis_interface.serialize.DefaultSerialize import DefaultSerialize


class PlySerialize(DefaultSerialize):
    r"""Class for serializing/deserializing .ply file formats.

    Args:
        write_header (bool, optional): If True, headers will be added to
            serialized output. Defaults to True.
        newline (str, optional): String that should be used for new lines.
            Defaults to '\n'.

    Attributes:
        write_header (bool): If True, headers will be added to serialized
            output.
        newline (str): String that should be used for new lines.
        default_rgb (list): Default color in RGB that should be used for
            missing colors.

    """
    
    def __init__(self, *args, **kwargs):
        self.write_header = kwargs.pop('write_header', True)
        self.newline = backwards.bytes2unicode(kwargs.pop('newline', '\n'))
        self.default_rgb = [0, 0, 0]
        super(PlySerialize, self).__init__(*args, **kwargs)

    @property
    def serializer_type(self):
        r"""int: Type of serializer."""
        return 8
        
    @property
    def empty_msg(self):
        r"""obj: Object indicating empty message."""
        return backwards.unicode2bytes('')
            
    def func_serialize(self, args):
        r"""Serialize a message.

        Args:
            args (dict): Dictionary of ply information. Fields include:
                vertices (list): 3D positions of vertices comprising the object.
                faces (list): Indices of 3 or more vertices making up faces.
                vertex_colors (list): RGB values for each of the vertices.
                    If not provided, all vertices will be black.

        Returns:
            bytes, str: Serialized message.

        """
        lines = []
        nvert = len(args.get('vertices', []))
        nface = len(args.get('faces', []))
        # Header
        if self.write_header:
            lines += ['ply',
                      'format ascii 1.0',
                      'comment author %s' % getpass.getuser(),
                      'comment File generated by cis_interface',
                      'element vertex %d' % nvert,
                      'property float x',
                      'property float y',
                      'property float z']
            if args.get('vertex_colors', []):
                lines += ['property uchar diffuse_red',
                          'property uchar diffuse_green',
                          'property uchar diffuse_blue']
            lines += ['element face %d' % nface,
                      'property list uchar int vertex_indices',
                      'end_header']
        # Set colors if not provided
        # if not args.get('vertex_colors', []):
        #     args['vertex_colors'] = []
        #     for v in args.get('vertices', []):
        #         args['vertex_colors'].append(self.default_rgb)
        # 3D objects
        if args.get('vertex_colors', []):
            for i in range(len(args.get('vertices', []))):
                v = args['vertices'][i]
                c = args['vertex_colors'][i]
                entry = tuple(list(v) + list(c))
                lines.append('%f %f %f %d %d %d' % entry)
        else:
            for i in range(len(args.get('vertices', []))):
                v = args['vertices'][i]
                entry = tuple(list(v))
                lines.append('%f %f %f' % entry)
        for f in args.get('faces', []):
            nv = len(f)
            iline = '%d' % nv
            for v in f:
                iline += ' %d' % v
            lines.append(iline)
        out = self.newline.join(lines)
        return backwards.unicode2bytes(out)

    def func_deserialize(self, msg, nvert=None, nface=None):
        r"""Deserialize a message.

        Args:
            msg (str, bytes): Message to be deserialized.
            nvert (int, optional): Number of vertices expected if the ply
                header is not in the message. Defaults to None.
            nface (int, optional): Number of faces expected if the ply
                header is not in the message. Defaults to None.

        Returns:
            dict: Deserialized .ply information.

        """
        if len(msg) == 0:
            out = self.empty_msg
        else:
            lines = backwards.bytes2unicode(msg).split(self.newline)
            # Split header and body
            headline = 0
            for i in range(len(lines)):
                if 'end_header' in lines[i]:
                    headline = i + 1
                    break
            if headline > 0:
                for i in range(headline):
                    if lines[i].startswith('element vertex'):
                        nvert = int(lines[i].split()[2])
                    elif lines[i].startswith('element face'):
                        nface = int(lines[i].split()[2])
            if (nvert is None) or (nface is None):  # pragma: debug
                raise RuntimeError("Could not locate element definitions.")
            # Get 3D info
            out = dict(vertices=[], faces=[], vertex_colors=[])
            i = headline
            while len(out['vertices']) < nvert:
                values = lines[i].split()
                if len(values) > 0:
                    out['vertices'].append([x for x in map(float, values[:3])])
                    if len(values) >= 6:
                        out['vertex_colors'].append([x for x in map(int, values[3:])])
                    else:
                        out['vertex_colors'].append(self.default_rgb)
                i += 1
            while len(out['faces']) < nface:
                values = lines[i].split()
                if len(values) > 0:
                    nv = int(values[0])
                    out['faces'].append([x for x in map(int, values[1:(nv + 1)])])
                    for x in out['faces'][-1]:
                        assert(x < len(out['vertices']))
                i += 1
        return out

    def apply_scalar_map(self, ply_dict, scalar_arr, color_map=None,
                         vmin=None, vmax=None, scaling='linear',
                         scale_by_area=False):
        r"""Set the color of faces in a 3D object based on a scalar map.

        Args:
            ply_dict (dict): Ply fields.
            scalar_arr (arr): Scalar values that should be mapped to colors
                for each face.
            color_map (str, optional): The name of the color map that should
                be used. Defaults to 'plasma'.
            vmin (float, optional): Value that should map to the minimum of the
                colormap. Defaults to min(scalar_arr).
            vmax (float, optional): Value that should map to the maximum of the
                colormap. Defaults to max(scalar_arr).
            scaling (str, optional): Scaling that should be used to map the scalar
                array onto the colormap. Defaults to 'linear'.
            scale_by_area (bool, optional): If True, the elements of the scalar
                array will be multiplied by the area of the corresponding face.
                If True, vmin and vmax should be in terms of the scaled array.
                Defaults to False.

        Returns:
            dict: Ply with updated vertex colors.

        """
        # Scale by area
        if scale_by_area:
            scalar_arr = copy.deepcopy(scalar_arr)
            for i in range(len(ply_dict['faces'])):
                f = ply_dict['faces'][i]
                v0 = np.array(ply_dict['vertices'][f[0]])
                v1 = np.array(ply_dict['vertices'][f[1]])
                v2 = np.array(ply_dict['vertices'][f[2]])
                a = np.sqrt(np.sum((v0 - v1)**2))
                b = np.sqrt(np.sum((v1 - v2)**2))
                c = np.sqrt(np.sum((v2 - v0)**2))
                s = (a + b + c) / 2.0
                area = np.sqrt(s * (s - a) * (s - b) * (s - c))
                scalar_arr[i] = area * scalar_arr[i]
        # Map vertices onto faces
        vertex_scalar = [[] for x in ply_dict['vertices']]
        for i in range(len(ply_dict['faces'])):
            for v in ply_dict['faces'][i]:
                vertex_scalar[v].append(scalar_arr[i])
        for i in range(len(vertex_scalar)):
            vertex_scalar[i] = np.mean(vertex_scalar[i])
        vertex_scalar = np.array(vertex_scalar)
        if scaling == 'log':
            vertex_scalar = np.ma.MaskedArray(vertex_scalar, vertex_scalar <= 0)
        # Get color scaling
        if color_map is None:
            # color_map = 'summer'
            color_map = 'plasma'
        if vmin is None:
            vmin = vertex_scalar.min()
        if vmax is None:
            vmax = vertex_scalar.max()
        # print(vmin, vmax)
        cmap = cm.get_cmap(color_map)
        if scaling == 'log':
            norm = mpl.colors.LogNorm(vmin=vmin, vmax=vmax)
        elif scaling == 'linear':
            norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax)
        else:  # pragma: debug
            raise Exception("Scaling must be 'linear' or 'log'.")
        m = cm.ScalarMappable(norm=norm, cmap=cmap)
        # Scale colors
        vertex_colors = (255 * m.to_rgba(vertex_scalar)).astype('int')[:, :3].tolist()
        out = copy.deepcopy(ply_dict)
        out['vertex_colors'] = vertex_colors
        return out
