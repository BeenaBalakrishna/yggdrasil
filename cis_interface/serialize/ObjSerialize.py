import getpass
from cis_interface import backwards
from cis_interface.serialize.DefaultSerialize import DefaultSerialize


class ObjSerialize(DefaultSerialize):
    r"""Class for serializing/deserializing .obj file formats. Reader
    adapted from https://www.pygame.org/wiki/OBJFileLoader.

    Args:
        write_header (bool, optional): If True, headers will be added to
            serialized output. Defaults to True.
        newline (str, optional): String that should be used for new lines.
            Defaults to '\n'.

    Attributes:
        write_header (bool): If True, headers will be added to serialized
            output.
        newline (str): String that should be used for new lines.

    """

    def __init__(self, *args, **kwargs):
        self.write_header = kwargs.pop('write_header', True)
        self.newline = backwards.bytes2unicode(kwargs.pop('newline', '\n'))
        super(ObjSerialize, self).__init__(*args, **kwargs)

    @property
    def serializer_type(self):
        r"""int: Type of serializer."""
        return 8
        
    @property
    def empty_msg(self):
        r"""obj: Object indicating empty message."""
        return backwards.unicode2bytes('')
            
    def func_serialize(self, args, zero_indexed=True):
        r"""Serialize a message.

        Args:
            args (dict): Dictionary of obj information. Fields include:
                material (str): Material to use for faces.
                vertices (list): 3D vertices comprising the object.
                normals (list): 3D normals for vertices.
                texcoords (list): 3D texture coordinates for vertices.
                faces (list): Indices of 3 or more vertices making up faces or a
                    tuple containing the indices for the position, texture
                    coordinate, and normal for each vertex in the face. This
                    information can also be provided in their own lists, but
                    there must be an entry for every face.
                face_texcoords (list): Indices of texture coordinates for each
                    vertex in the face. Entries of None are ignored.
                face_normals (list): Indices of normals for each vertex in the
                    face. Entries of None are ignored.
            zero_indexed (bool, optional): If True, the input indices are assumed
                to start at zero and they will be adjusted to start at one and
                conform with .obj format. If False, the input indices are assumed
                to start at one and they will not be adjusted. Defaults to True.
               
        Returns:
            bytes, str: Serialized message.

        """
        lines = []
        # Header
        if self.write_header:
            lines += ['# Author %s' % getpass.getuser(),
                      '# Generated by cis_interface', '']
        if args.get('material', None) is not None:
            lines.append('usemtl %s' % args['material'])
        if 'vertices' in args:
            for v in args['vertices']:
                lines.append('v %f %f %f' % tuple(v))
        if 'normals' in args:
            for v in args['normals']:
                lines.append('vn %f %f %f' % tuple(v))
        if 'texcoords' in args:
            for v in args['texcoords']:
                lines.append('vt %f %f' % tuple(v))
        if 'faces' in args:
            faces = []
            # Convert faces to tuple
            for f in args['faces']:
                iface = []
                for v in f:
                    if issubclass(v.__class__, (int, float)):
                        iface.append([v, None, None])
                    else:
                        iface.append(list(v))
                faces.append(iface)
            # Fill in texture coordinates & normals from array
            face_keys = {'face_texcoords': 1, 'face_normals': 2}
            for key, key_index in face_keys.items():
                if args.get(key, []):
                    for i in range(len(faces)):
                        f = faces[i]
                        t = args[key][i]
                        if t is None:
                            continue
                        for j in range(len(f)):
                            if t[j] is None:
                                continue
                            f[j][key_index] = t[j]
            # Add lines
            add_ind = 0
            if zero_indexed:
                add_ind = 1
            for f in faces:
                iline = 'f'
                for j in range(len(f)):
                    v = f[j]
                    iline += ' %d/' % (v[0] + add_ind)
                    if v[1] is not None:
                        iline += '%d' % (v[1] + add_ind)
                    iline += '/'
                    if v[2] is not None:
                        iline += '%d' % (v[2] + add_ind)
                lines.append(iline)
        out = self.newline.join(lines)
        return backwards.unicode2bytes(out)

    def func_deserialize(self, msg, zero_indexed=True):
        r"""Deserialize a message.

        Args:
            msg (str, bytes): Message to be deserialized.
            zero_indexed (bool, optional): If True, the parsed indices are adjusted
                to start at zero. If False, the indices will not be adjusted and
                will start at one as per .obj format. Defaults to True.

        Returns:
            dict: Deserialized .obj information. The faces are zero indexed.

        """
        if len(msg) == 0:
            out = self.empty_msg
        else:
            lines = backwards.bytes2unicode(msg).split(self.newline)
            out = dict(vertices=[], material=None, normals=[], texcoords=[],
                       faces=[], face_texcoords=[], face_normals=[])
            for line in lines:
                if line.startswith('#'):
                    continue
                values = line.split()
                if not values:
                    continue
                if values[0] == 'v':
                    out['vertices'].append([x for x in map(float, values[1:4])])
                elif values[0] == 'vn':
                    out['normals'].append([x for x in map(float, values[1:4])])
                elif values[0] == 'vt':
                    out['texcoords'].append([x for x in map(float, values[1:3])])
                elif values[0] in ('usemtl', 'usemat'):
                    out['material'] = values[1]
                elif values[0] == 'f':
                    sub_ind = 0
                    if zero_indexed:
                        sub_ind = 1
                    face = []
                    texcoords = []
                    norms = []
                    for v in values[1:]:
                        w = v.split('/')
                        face.append(int(w[0]) - sub_ind)
                        itexc = None
                        inorm = None
                        if len(w) >= 2 and len(w[1]) > 0:
                            itexc = int(w[1]) - sub_ind
                        texcoords.append(itexc)
                        if len(w) >= 3 and len(w[2]) > 0:
                            inorm = int(w[2]) - sub_ind
                        norms.append(inorm)
                    out['faces'].append(face)
                    out['face_texcoords'].append(texcoords)
                    out['face_normals'].append(norms)
                    for x in out['faces'][-1]:
                        assert(x <= (len(out['vertices']) - sub_ind))
        return out
