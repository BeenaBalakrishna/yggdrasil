%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional\else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}

\usepackage{geometry}
\usepackage{multirow}
\usepackage{eqparbox}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{cis\_interface Documentation}
\date{Sep 06, 2017}
\release{0.0.0}
\author{Meagan Lang, David Raila}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Model Integration and Communications Architecture}
\label{\detokenize{includeme:model-integration-and-communications-architecture}}\label{\detokenize{includeme::doc}}\label{\detokenize{includeme:welcome-to-cis-interface-s-documentation}}

\section{Overview}
\label{\detokenize{includeme:overview}}
The CiS model system provides integration and communications support for
model providers. Modelers add simple communications interfaces within
their model code, and provide a simple declarative specification that
informs the system of the names and types of inputs and outputs of the
model and the commands required to run the model.

The system uses the specification to configure the communications
channels and bind them into the model. The complexity of the particular
communications system is managed by a model driver that performns
communication setup, binds the communications to a simple interface
within the model, and manages the model's exection. The complexities of
model registration and discovery, as well as the complexities of setup
and management of the communications system are handled by the model
driver under direction of the model specification, freeing the model
programmer from implementing communications protocols of any particular
messaging infrastructure. The model programmer is provided with a very
simple and easy to use abstract send/receive message interface using
basic IPC mechanisms available in that binds in virtually every language
and platform.

The model communications interface consists of 2 pairs of very simple
functions - one pair to create channels and one pair to accomplish data
tranfer. Each pair represents a read-side and a write-side.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{psi\PYGZus{}input}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}  \PYG{o}{\PYGZhy{}} \PYG{n}{create} \PYG{n}{a} \PYG{n}{named} \PYG{n+nb}{input} \PYG{n}{channel}
\PYG{n}{psi\PYGZus{}output}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{create} \PYG{n}{a} \PYG{n}{named} \PYG{n}{output} \PYG{n}{channel}

\PYG{n}{psi\PYGZus{}send}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{n}{data}\PYG{p}{)}   \PYG{o}{\PYGZhy{}} \PYG{n}{send} \PYG{n}{a} \PYG{n}{message} \PYG{n}{through} \PYG{n}{the} \PYG{n}{managed} \PYG{n}{channel}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{psi\PYGZus{}recv}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}  \PYG{o}{\PYGZhy{}} \PYG{n}{receive} \PYG{n}{message} \PYG{k+kn}{from} \PYG{n+nn}{channel} \PYG{o}{\PYGZhy{}} \PYG{n}{block} \PYG{k}{if} \PYG{n}{empty} \PYG{n}{channel}
\end{sphinxVerbatim}

C-style is shown, but as these interfaces are thin wrappers around
System V IPC message queues, equivalent thin-wrappers are implemented
easily in almost any language. Models may create and use as many
channels as necessary, depending on the number of interfaces that they
require.

The only other model requirement is to provide a YAML specification file
that declares the channels that the model uses, and the system command
required to start the model executing.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{p}{:}
  \PYG{n}{name}\PYG{p}{:} \PYG{n}{hellopython}
  \PYG{n}{driver}\PYG{p}{:} \PYG{n}{ModelDriver}
  \PYG{n}{args}\PYG{p}{:} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{python}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hellopython.py}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{]}

  \PYG{n}{inputs}\PYG{p}{:}
    \PYG{o}{\PYGZhy{}} \PYG{n}{name}\PYG{p}{:} \PYG{n}{inputFile}
      \PYG{n}{driver}\PYG{p}{:} \PYG{n}{FileInputDriver}
      \PYG{n}{args}\PYG{p}{:} \PYG{n}{inputdata}\PYG{o}{/}\PYG{n+nb}{input}\PYG{o}{.}\PYG{n}{txt}
      \PYG{n}{onexit}\PYG{p}{:} \PYG{n}{delete}    \PYG{c+c1}{\PYGZsh{} delete the queue when the model exits}
    \PYG{o}{\PYGZhy{}} \PYG{n}{name}\PYG{p}{:} \PYG{n}{fooInputChannel}
      \PYG{n}{driver}\PYG{p}{:} \PYG{n}{RMQInputDriver}
      \PYG{n}{args}\PYG{p}{:} \PYG{n}{fooqueue}
      \PYG{n}{onexit}\PYG{p}{:} \PYG{n}{delete}    \PYG{c+c1}{\PYGZsh{} delete the queue when the model exits}

  \PYG{n}{outputs}\PYG{p}{:}
    \PYG{o}{\PYGZhy{}} \PYG{n}{name}\PYG{p}{:} \PYG{n}{fooOutput}
      \PYG{n}{driver}\PYG{p}{:} \PYG{n}{RMQOutputDriver}
\end{sphinxVerbatim}

This example tells the system to run your model as if you typed \sphinxquotedblleft{}python
hellopython.py\sphinxquotedblright{} and to connect the file inputdata/input.txt to the
psi\_input named `inputFile' in your model, so when you recv() on it,
you'll get the file contents. Likewise when you send(data\_to\_send) to
the channel you made in your code with psi\_output(`fooOutput') the data
will go to the message queue names FooOutput.

You may have multiple inputs and multiple outputs as you need. If you
send to a RMQOutput named `fred' your another model can use fred as a
RMQInput to read from and get your messages. By keeping multiple yml
files around with different inputs and outputs but the same model stanza
you can test with different data inputs and outputs conveniently without
changing the model code.

The finel part is the model wrapper, PsiRun.py - to which you pass your
yml file. The model wrapper reads the specification, arranges for your
inputs and outputs to come and go as you've specified, and then calls
your model with the arguments as specified in the model stanza. The
model runs, using the send and recv calls as needed, and when the model
exits, the communications get cleaned up bu the wrapper. The exmaple
hellopython.py under examples is run like this (in examples/python):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{n}{interface}\PYG{o}{/}\PYG{n}{PsiRun}\PYG{o}{.}\PYG{n}{py} \PYG{n}{hellopython}\PYG{o}{.}\PYG{n}{yml}
\end{sphinxVerbatim}

The code in hellopython.py uses the channels:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{inf} \PYG{o}{=} \PYG{n}{PsiInput}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{infile}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{outf} \PYG{o}{=} \PYG{n}{PsiOutput}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{outfile}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{inq} \PYG{o}{=} \PYG{n}{PsiInput}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{helloQueue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{outq} \PYG{o}{=} \PYG{n}{PsiOutput}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{helloQueue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{buf} \PYG{o}{=} \PYG{n}{inf}\PYG{o}{.}\PYG{n}{recv}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{outq}\PYG{o}{.}\PYG{n}{send}\PYG{p}{(}\PYG{n}{buf}\PYG{p}{)}
\PYG{n}{buf} \PYG{o}{=} \PYG{n}{inq}\PYG{o}{.}\PYG{n}{recv}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{outf}\PYG{o}{.}\PYG{n}{send}\PYG{p}{(}\PYG{n}{buf}\PYG{p}{)}
\end{sphinxVerbatim}

The yaml file says to run the model, and connects the inputs and
outputs:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{p}{:}
  \PYG{n}{name}\PYG{p}{:} \PYG{n}{hellopython}
  \PYG{n}{driver}\PYG{p}{:} \PYG{n}{ModelDriver}
  \PYG{n}{args}\PYG{p}{:} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{python}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hellopython.py}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{]}

  \PYG{n}{inputs}\PYG{p}{:}
    \PYG{o}{\PYGZhy{}} \PYG{n}{name}\PYG{p}{:} \PYG{n}{infile}
      \PYG{n}{driver}\PYG{p}{:} \PYG{n}{FileInputDriver}
      \PYG{n}{filename}\PYG{p}{:} \PYG{n+nb}{input}\PYG{o}{.}\PYG{n}{txt}
    \PYG{o}{\PYGZhy{}} \PYG{n}{name}\PYG{p}{:} \PYG{n}{helloQueue}
      \PYG{n}{driver}\PYG{p}{:} \PYG{n}{RMQInputDriver}

  \PYG{n}{outputs}\PYG{p}{:}
    \PYG{o}{\PYGZhy{}} \PYG{n}{name}\PYG{p}{:} \PYG{n}{helloQueue}
      \PYG{n}{driver}\PYG{p}{:} \PYG{n}{RMQOutputDriver}
    \PYG{o}{\PYGZhy{}} \PYG{n}{name}\PYG{p}{:} \PYG{n}{outFile}
      \PYG{n}{driver}\PYG{p}{:} \PYG{n}{FileOutputDriver}
      \PYG{n}{filename}\PYG{p}{:} \PYG{n}{output}\PYG{o}{.}\PYG{n}{txt}
\end{sphinxVerbatim}


\section{Installation notes}
\label{\detokenize{includeme:installation-notes}}\begin{itemize}
\item {} 
Matlab

\item {} 
Matlab uses the python interface directly

\item {} 
Remove the matlab crypto and ssl libraries and install the python
engine sudo -s rm -f
./R2015b/toolbox/compiler\_sdk/mps\_clients/c/glnxa64/lib/libcrypto.so.1
rm -f
./R2015b/toolbox/compiler\_sdk/mps\_clients/c/glnxa64/lib/libcrypto.so
rm -f
./R2015b/toolbox/compiler\_sdk/mps\_clients/c/glnxa64/lib/libcrypto.so.1.0.0
rm -f ./R2015b/bin/glnxa64/libcrypto.so.1 rm -f
./R2015b/bin/glnxa64/libcrypto.so.1.0.0 rm -f
./R2015b/toolbox/compiler\_sdk/mps\_clients/c/glnxa64/lib/libssl.so.1
rm -f
./R2015b/toolbox/compiler\_sdk/mps\_clients/c/glnxa64/lib/libssl.so.1.0.0
rm -f
./R2015b/toolbox/compiler\_sdk/mps\_clients/c/glnxa64/lib/libssl.so
rm -f
./R2015b/sys/jxbrowser/glnxa64/xulrunner/xulrunner-linux-64/libssl3.so
rm -f ./R2015b/bin/glnxa64/libssl.so.1 rm -f
./R2015b/bin/glnxa64/libssl.so.1.0.0 cd
/usr/local/MATLAB/R2015b/extern/engines/python python setup.py

\end{itemize}


\section{Contents}
\label{\detokenize{includeme:contents}}\begin{itemize}
\item {} 
\sphinxstylestrong{build} - model build help and container builders

\item {} 
docker - build containers (in progress)

\item {} 
\sphinxstylestrong{edge-example} - full example in python, matlab, C(++)

\item {} 
models - models and specifications

\item {} 
app

\item {} 
\sphinxstylestrong{lib} - Common services and drivers

\item {} 
drivers - inputs, outputs, messaging, model-wrapper

\item {} 
yml - yaml specification support

\item {} 
controller - cli PSi system setup/run

\end{itemize}


\section{Functional Architecture}
\label{\detokenize{includeme:functional-architecture}}\begin{itemize}
\item {} 
Models

\item {} 
Provide callable functions (ml, c, python)
\begin{itemize}
\item {} 
Function(s) take an input, returns an output

\item {} 
A function to set optional parameters

\end{itemize}

\item {} 
Provide a specification - yaml file
\begin{itemize}
\item {} 
Describes the model, inputs, outputs, function names, files to
use, filenames to store output

\end{itemize}

\item {} 
Driver

\item {} 
A driver is a `wrapper' or adapter that encapsulates other objects or
functions, perhaps in other languages or platforms, into a callable
python object - for example the MatlabCaller encapsulates the Matlab
runtime and callable function in a clean python object.

\item {} 
Controller - A python cli program that runs and feeds the models

\item {} 
Reads the specifications

\item {} 
Setup and connect the queues

\item {} 
Setup the models inside model drivers

\item {} 
Setup the input and output drivers

\item {} 
Sets all drivers to running
\begin{itemize}
\item {} 
Input drivers send data into queues

\item {} 
Model drivers receive inputs, call model processing functions,
send outputs to downstream queue drivers and/or output drivers

\end{itemize}

\end{itemize}


\section{Advantages}
\label{\detokenize{includeme:advantages}}\begin{itemize}
\item {} 
The demands on model providers is greatly simplified

\item {} 
Model contains only domain-specific model code - focused

\item {} 
No coding based on unfamilar techniques, languages, etc.
\begin{itemize}
\item {} 
System code, protocols, services, and languages outside of a
modelers area of expertise

\end{itemize}

\item {} 
The specification is much simpler to create and maintain than code

\item {} 
Declare what the model wants, take inputs, produce outputs and let
the system do the rest

\item {} 
Single system modules and drivers are easier to maintain and evolve

\item {} 
Messaging, data-handling, and system run-time facilities become
shared and isolated, bounded in their impact

\item {} 
Easier to understand, easier to maintain
\begin{itemize}
\item {} 
Fixing a shared driver is preferrable to system code embedded in
multiple models

\end{itemize}

\end{itemize}


\section{Development Notes: Installation and test code fragments}
\label{\detokenize{includeme:development-notes-installation-and-test-code-fragments}}
Python to matlabs setup: cd
/usr/local/MATLAB/R2015b/extern/engines/python sudo python setup.py
install.


\subsection{Python protocols Matlab}
\label{\detokenize{includeme:python-protocols-matlab}}
from psimsg import * import matlab.engine eng =
matlab.engine.connect\_matlab()


\subsection{Matlab to Python}
\label{\detokenize{includeme:matlab-to-python}}
Matlab only seems limited to storing basic data (ints/floats/arrays),
unable to receive objects from python for storage/calling P =
py.sys.path; append(P, pwd); import psimsg.*


\chapter{Installation}
\label{\detokenize{install:installation}}\label{\detokenize{install::doc}}

\section{Basic Installation}
\label{\detokenize{install:basic-installation}}
..todo:: Links to PyPI release

{\color{red}\bfseries{}\textbar{}cis\_interface\textbar{}} can be installed from either PyPI using \sphinxcode{pip}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} pip install cis\PYGZus{}interface
\end{sphinxVerbatim}

or by cloning the \sphinxhref{https://git-scm.com/}{Git} repository on \sphinxhref{https://github.com/cropsinsilico/cis\_interface}{Github}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} git clone https://github.com/cropsinsilico/cis\PYGZus{}interface.git
\end{sphinxVerbatim}

and then building the distribution.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} cd cis\PYGZus{}interface
\PYGZdl{} python setup.py install
\end{sphinxVerbatim}

If you do not have admin privileges on the target machine, \sphinxcode{-{-}user} can be added to either the \sphinxcode{pip} or \sphinxcode{setup.py} installation commands.


\section{Additional Steps for Matlab Models}
\label{\detokenize{install:additional-steps-for-matlab-models}}
To run Matlab models, you will also need to install the Matlab engine for
Python. This requires that you have an existing Matlab installation and license.

Instructions for installing the Matlab engine as a python package can be found
\sphinxhref{https://www.mathworks.com/help/matlab/matlab\_external/install-the-matlab-engine-for-python.html}{\textless{}here}.


\section{Additional Steps for RabbitMQ Message Passing}
\label{\detokenize{install:additional-steps-for-rabbitmq-message-passing}}

\chapter{Code}
\label{\detokenize{code:code}}\label{\detokenize{code::doc}}\phantomsection\label{\detokenize{code:module-cis_interface}}\index{cis\_interface (module)}
This package provides a framework for integrating models across languages
such that they can be run simultaneously, passing input back and forth.
\index{interface (in module cis\_interface)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{code:cis_interface.interface}}\pysigline{\sphinxcode{cis\_interface.}\sphinxbfcode{interface}}
alias of {\hyperref[\detokenize{code:cis_interface.interface}]{\sphinxcrossref{\sphinxcode{cis\_interface.interface}}}}

\end{fulllineitems}

\index{drivers (in module cis\_interface)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{code:cis_interface.drivers}}\pysigline{\sphinxcode{cis\_interface.}\sphinxbfcode{drivers}}
alias of {\hyperref[\detokenize{code:cis_interface.drivers}]{\sphinxcrossref{\sphinxcode{cis\_interface.drivers}}}}

\end{fulllineitems}

\index{dataio (in module cis\_interface)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{code:cis_interface.dataio}}\pysigline{\sphinxcode{cis\_interface.}\sphinxbfcode{dataio}}
alias of {\hyperref[\detokenize{code:cis_interface.dataio}]{\sphinxcrossref{\sphinxcode{cis\_interface.dataio}}}}

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{c}
\item {\sphinxstyleindexentry{cis\_interface}}\sphinxstyleindexpageref{code:\detokenize{module-cis_interface}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}